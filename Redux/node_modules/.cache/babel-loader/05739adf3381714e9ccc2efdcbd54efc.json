{"ast":null,"code":"var util = require('utils-extend');\n\nvar fs = require('file-system');\n\nvar path = require('path');\n\nvar StreamSearch = require('streamsearch');\n\nvar EventEmitter = require('events').EventEmitter; // Some options borrow from jQuery.fileupload\n\n\nfunction Upload(options) {\n  this.options = util.extend({\n    dest: '',\n    minFileSize: 0,\n    maxFileSize: Infinity,\n    maxNumberOfFiles: Infinity,\n    minNumberOfFiles: 1,\n    messages: {\n      maxNumberOfFiles: 'Maximum number of files exceeded',\n      minNumberOfFiles: 'Less than minimum number of files',\n      acceptFileTypes: 'File type not allowed',\n      maxFileSize: 'File is too large',\n      minFileSize: 'File is too small',\n      invalidRequest: 'Invalid request'\n      /*\n      // The regular expression for allowed file types, matches\n      // against either file type or file name:\n      acceptFileTypes: /(\\.|\\/)(gif|jpe?g|png)$/i,\n      */\n\n    }\n  }, options);\n  this._isError = false;\n  this._chunks = [];\n  this.files = {};\n  this.fields = {};\n  this._writed = 0;\n  fs.mkdirSync(this.options.dest);\n}\n\nutil.inherits(Upload, EventEmitter);\n/**\n * @description\n * Parse the http request\n */\n\nUpload.prototype.parse = function (req) {\n  var self = this;\n  var contentType = req.headers['content-type'];\n\n  if (!contentType) {\n    return this.emit('error', this.options.messages.invalidRequest);\n  }\n\n  var boundary = '\\r\\n--' + getBoundary(contentType);\n  this.search = new StreamSearch(new Buffer(boundary));\n  this.search.on('info', this._oninfo.bind(this)); // handle request object\n\n  req.on('data', function (chunk) {\n    self._chunks.push(chunk);\n  }).on('end', function () {\n    var buffer = Buffer.concat(self._chunks);\n    var files = buffer.toString().match(/Content-Disposition:.+?filename=\"([^\"]+)\"/g);\n    files = files ? files.length : 0;\n    self._filesNumber = files;\n\n    if (files > self.options.maxNumberOfFiles) {\n      return self.error(self.options.messages.maxNumberOfFiles);\n    }\n\n    if (files < self.options.minNumberOfFiles) {\n      return self.error(self.options.messages.minNumberOfFiles);\n    }\n\n    self.search.push(buffer);\n\n    if (isNoneFiles(self.files)) {\n      self.emit('end', self.fields, self.files);\n    }\n  });\n};\n\nUpload.prototype.error = function (msg) {\n  if (this._isError) return;\n  this._isError = true;\n  this.emit('error', msg);\n};\n/**\n * @description\n * If the form is invalid, you can invoke this method for clear unnecessary file\n */\n\n\nUpload.prototype.cleanup = function () {\n  var files = this.files;\n\n  for (var i in files) {\n    var file = files[i];\n\n    if (Array.isArray(file)) {\n      file.forEach(function (item) {\n        if (item.filename) {\n          fs.unlink(item.path, util.noop);\n        }\n      });\n    } else if (file.filename) {\n      fs.unlink(file.path, util.noop);\n    }\n  }\n};\n\nUpload.prototype._oninfo = function (isMatch, data, start, end) {\n  if (!data || !isMatch) return;\n  var result = data.slice(start, end);\n\n  this._parsePart(result);\n};\n\nUpload.prototype._parsePart = function (data) {\n  var result = splitHeaderBody(data);\n  var header = result.header.toString();\n  var disposition = header.match(/Content-Disposition:.+/);\n  var options = this.options;\n\n  if (!disposition) {\n    return this.error(options.messages.invalidRequest);\n  }\n\n  disposition = disposition[0];\n  var name = disposition.match(/name=\"([^\"]+)\"/);\n\n  if (!name) {\n    return this.error(options.messages.invalidRequest);\n  }\n\n  name = name[1];\n  var filename = disposition.match(/filename=\"([^\"]*)\"/);\n\n  if (!filename) {\n    this._parseValue(this.fields, name, result.body.toString());\n\n    return;\n  }\n\n  filename = filename[1];\n  var type = header.match(/Content-Type:\\s*(.+)/);\n  var file = {\n    filename: filename,\n    path: path.join(options.dest, filename),\n    type: type ? type[1] : '',\n    size: result.body.length\n  };\n\n  this._parseValue(this.files, name, file); // empty input file\n\n\n  if (!filename) return; // Rename file\n\n  if (util.isFunction(options.rename)) {\n    file.filename = options.rename.call(this, name, file);\n  }\n\n  if (!this.validate(file)) return;\n\n  this._write(file.filename, result.body);\n}; // Value is array, like key[]=1&key[]=2, and key=1&key=2\n\n\nUpload.prototype._parseValue = function (obj, name, value) {\n  var isArray = /\\[\\]$/.test(name);\n\n  if (isArray) {\n    name = name.replace(/\\[\\]$/, '');\n  }\n\n  if (util.isUndefined(obj[name])) {\n    if (isArray) {\n      obj[name] = [value];\n    } else {\n      obj[name] = value;\n    }\n  } else {\n    if (Array.isArray(obj[name])) {\n      obj[name].push(value);\n    } else {\n      obj[name] = [obj[name], value];\n    }\n  }\n};\n\nUpload.prototype._write = function (filename, body) {\n  var filepath = path.join(this.options.dest, filename); // upload folder\n\n  if (path.dirname(filename) !== '.') {\n    fs.mkdirSync(path.dirname(filepath));\n  } // upload file\n\n\n  var part = fs.createWriteStream(filepath);\n  var self = this;\n  part.on('finish', function () {\n    self._writed++;\n\n    if (self._writed >= self._filesNumber) {\n      self.emit('end', self.fields, self.files);\n    }\n  });\n  part.on('error', function (err) {\n    self.error(err);\n  });\n  part.write(body);\n  part.end();\n}; // Validate the name, type, max size and min size of each file\n\n\nUpload.prototype.validate = function (file) {\n  var options = this.options;\n\n  if (options.acceptFileTypes && !(options.acceptFileTypes.test(file.type) || options.acceptFileTypes.test(file.name))) {\n    this.error(options.messages.acceptFileTypes);\n    return false;\n  } else if (file.size > options.maxFileSize) {\n    this.error(options.messages.maxFileSize);\n    return false;\n  } else if (file.size < options.minFileSize) {\n    this.error(options.messages.minFileSize);\n    return false;\n  }\n\n  return true;\n}; // RFC2046\n\n\nfunction getBoundary(contentType) {\n  contentType = contentType.split(/;\\s*/);\n\n  if (contentType) {\n    return contentType[1].replace('boundary=', '');\n  }\n\n  return '';\n}\n\nfunction splitHeaderBody(data) {\n  // CRLF\n  var CR = 13;\n  var LF = 10;\n  var item;\n  var start;\n\n  for (var i = 0, l = data.length - 3; i < l; i++) {\n    item = data[i];\n\n    if (item === CR) {\n      if (data[i + 1] === LF && data[i + 2] === CR && data[i + 3] === LF) {\n        start = i;\n        break;\n      }\n    }\n  }\n\n  if (start) {\n    return {\n      header: data.slice(0, start),\n      body: data.slice(start + 4)\n    };\n  } else {\n    return {\n      header: {\n        data: data,\n        body: new Buffer(0)\n      }\n    };\n  }\n}\n\nfunction isNoneFiles(files) {\n  for (var i in files) {\n    if (Array.isArray(files[i])) {\n      var l = files[i].length;\n\n      while (l--) {\n        if (files[i][l].filename) {\n          return false;\n        }\n      }\n    } else if (files[i].filename) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = Upload;","map":null,"metadata":{},"sourceType":"script"}
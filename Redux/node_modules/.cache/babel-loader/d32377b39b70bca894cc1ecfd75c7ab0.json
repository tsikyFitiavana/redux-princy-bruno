{"ast":null,"code":"var Busboy = require('busboy');\n\nvar fileFactory = require('./fileFactory');\n\nvar memHandler = require('./memHandler');\n\nvar tempFileHandler = require('./tempFileHandler');\n\nvar processNested = require('./processNested');\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\n\n\nmodule.exports = function processMultipart(options, req, res, next) {\n  var busboyOptions = {};\n  var busboy;\n  req.files = null; // Build busboy config\n\n  for (var k in options) {\n    if (Object.prototype.hasOwnProperty.call(options, k)) {\n      busboyOptions[k] = options[k];\n    }\n  } // Attach request headers to busboy config\n\n\n  busboyOptions.headers = req.headers; // Init busboy instance\n\n  busboy = new Busboy(busboyOptions); // Build multipart req.body fields\n\n  busboy.on('field', function (fieldname, val) {\n    req.body = req.body || {};\n    var prev = req.body[fieldname];\n\n    if (!prev) {\n      return req.body[fieldname] = val;\n    }\n\n    if (Array.isArray(prev)) {\n      return prev.push(val);\n    }\n\n    req.body[fieldname] = [prev, val];\n  }); // Build req.files fields\n\n  busboy.on('file', function (fieldname, file, filename, encoding, mime) {\n    var _ref = options.useTempFiles ? tempFileHandler(options, fieldname, filename) : memHandler(options, fieldname, filename),\n        dataHandler = _ref.dataHandler,\n        getFilePath = _ref.getFilePath,\n        getFileSize = _ref.getFileSize,\n        getHash = _ref.getHash,\n        complete = _ref.complete,\n        cleanup = _ref.cleanup;\n\n    file.on('limit', function () {\n      if (options.abortOnLimit) {\n        res.writeHead(413, {\n          Connection: 'close'\n        });\n        res.end('File size limit has been reached');\n      }\n    });\n    file.on('data', dataHandler);\n    file.on('end', function () {\n      if (!req.files) {\n        req.files = {};\n      }\n\n      var buffer = complete(filename); // see: https://github.com/richardgirges/express-fileupload/issues/14\n      // firefox uploads empty file in case of cache miss when f5ing page.\n      // resulting in unexpected behavior. if there is no file data, the file is invalid.\n\n      if (!buffer.length && !options.useTempFiles) {\n        return;\n      }\n\n      if (options.safeFileNames) {\n        var safeFileNameRegex = /[^\\w-]/g;\n        var maxExtensionLength = 3;\n        var extension = '';\n\n        if (typeof options.safeFileNames === 'object') {\n          safeFileNameRegex = options.safeFileNames;\n        }\n\n        maxExtensionLength = parseInt(options.preserveExtension);\n\n        if (options.preserveExtension || maxExtensionLength === 0) {\n          if (isNaN(maxExtensionLength)) {\n            maxExtensionLength = 3;\n          } else {\n            maxExtensionLength = Math.abs(maxExtensionLength);\n          }\n\n          var filenameParts = filename.split('.');\n          var filenamePartsLen = filenameParts.length;\n\n          if (filenamePartsLen > 1) {\n            extension = filenameParts.pop();\n\n            if (extension.length > maxExtensionLength && maxExtensionLength > 0) {\n              filenameParts[filenameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtensionLength);\n              extension = extension.substr(-maxExtensionLength);\n            }\n\n            extension = maxExtensionLength ? '.' + extension.replace(safeFileNameRegex, '') : '';\n            filename = filenameParts.join('.');\n          }\n        }\n\n        filename = filename.replace(safeFileNameRegex, '').concat(extension);\n      }\n\n      var newFile = fileFactory({\n        name: filename,\n        buffer: buffer,\n        tempFilePath: getFilePath(),\n        size: getFileSize(),\n        hash: getHash(),\n        encoding: encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options); // Non-array fields\n\n      if (!req.files.hasOwnProperty(fieldname)) {\n        req.files[fieldname] = newFile;\n      } else {\n        // Array fields\n        if (req.files[fieldname] instanceof Array) {\n          req.files[fieldname].push(newFile);\n        } else {\n          req.files[fieldname] = [req.files[fieldname], newFile];\n        }\n      }\n    });\n    file.on('error', cleanup, next);\n  });\n  busboy.on('finish', function () {\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    next();\n  });\n  busboy.on('error', next);\n  req.pipe(busboy);\n};","map":null,"metadata":{},"sourceType":"script"}